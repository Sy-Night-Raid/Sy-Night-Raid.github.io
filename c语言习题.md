# 第一部分 基础篇        
      
## 0x0 基本库函数的使用
* 问题描述：编制100以内两个整数（随机产生）的加法运算练习程序

```c
#include<stdio.h>                 
#include<stdlib.h>                         
int main()                     
{                           
	int  a,b,c,x=0;  // 本题是计算100以内两个数的和，所以至少要定义三个int型变量a，b，c，分别表示加数，被加数，和       
	a=rand()%100;     // 随机数函数rand（）原型在‘stdlib.h’文件中           
	b=rand()%100;      // 每调用一次rand（） ，便产生一个0~32767之间的随机数，所以如果想要一个0~99之间的随机数，就要用rand（）%100就得到啦       
	printf("\n%d+%d=",a,b);           
	scanf("%d",&c);          
	if(c==a+b){              
		printf("The answer is right!\n");               
	}               
	else {              
		printf("The answer is wrong!\n");             
		printf("The right answer is %d+%d=%d\n",a,b,a+b);              
	}                
	return 0;                  
	
}                 
```
            
## 0x1 基本数据类型的使用
* 问题描述：编写一个程序，当输入小写字母时，程序能自动转换为大写字母；当输入大写字母时，程序能自动转换为小写字母；当输入非字母时，不进行任何转换；当输入非字母“#”时，程序结束。
```c
#include<stdio.h>
int main()
{
	char c;
	do{
		scanf("%c",&c);
		if(c>='a'&&c<='z'){
			printf("%c",c-32);
		}
		else if(c>='A'&&c<='Z'){
			printf("%c",c+32);
		}
	}while(c!='#');   //注意这个#也是符号，只要是符号就必须包裹在'中' 
	return 0;
	
 } 
 /* 1.我们运行了一下，发现很有趣哦我输单个字母s会出来大写字母S，我们输入wofer会出来大写WOFER，不管你输入多少字母都能一次性转换；直到输入#会终止程序 
  2.有趣的一点是虽然我们scanf（）输入的是字符类型%c，但如果我们把printf中改成%d，则会出现我们输入s出来一个数的情况，很有趣，因为在内存中
  字符型数据是以ASCII码存储的，所以c语言中字符数据char和整型int之间可以通用。一个字符数据既可以以字符形式输出，也可以以整数形式输出
  3.以字符形式输出时，需要先将存储单元中的ASCII码转换成相应字符，然后输出。以整数形式输出时，直接将ASCII码作为整数输出 
  4.也可以对字符数据惊醒算术运算，此时相当于对它们的ASCII码进行算术运算
  ！！！！说白了，字符数据的根本就是数字 */ 

```         
```c
#include<stdio.h>
int main()
{
	char c;
	while(c!='#'){
		 	scanf("%c",&c);
		if(c>='a'&&c<='z'){
			printf("%c",c-32);
		}
		else if(c>='A'&&c<='Z'){
			printf("%c",c+32);
		}
	}
	return 0; 
	

	
 } 
 //在此题中，while和do while没有任何区别，用谁都可以
```
            
## 0x2 求一元二次方程的根
* 问题描述：用else if结构在复数范围内求解一元二次方程的根
```c
这个程序因为对我以后的方向不是很有用，只记住以下几点即可
求实数绝对值和平方根的库函数分别为fabs()和sqrt()，这两个函数原型在文件“math.h”中
```
         
## 0x3 个人收入所得税
* 问题描述：假设公民交纳个人所得税的税率如下（a代表个人收入，r代表税率）：        
          r=0（a<2000元）    
	  r=5%（2000元<=a<3000元）     
	  r=10%（3000元<=a<4000元）           
	  r=15%（4000元<=a<5000元）     
	  r=20%（5000元<=a）      
    	  编写程序，要求从键盘上输入个人收入，根据以上税率计算出相应的税金并输出
    
 * 提示：需要用到switch-case语句
 ```c
 #include<stdio.h>
int main()
{
	float a,b;
	printf("请输入某人收入：");
	scanf("%f",&a);
	int i;
	if(a>=5000){
		i=5;
	}
	else i=a/1000;
	switch(i)
	{
		case 0:
			case 1:b=0;break;
			case 2:b=0.05*(a-2000);break;  
			case 3:b=50+0.1*(a-3000);break;  //这里前面为什么要加50呢，这是因为假如有3000的收入，那么有2000是没有税金的，2000~3000的那1000是按5%的税率收的所以算3000以上的都要先加上那1000的税金 
			case 4:b=50+100+0.15*(a-4000);break; // 前面为什么要加150的原因和上面一样 
			case 5:b=50+100+150+0.2*(a-5000);break;
	}
	printf("你应付的税金为：%.4f\n",b);
	return 0;
	
	
	
}
 ```
                
 ## 0x4 判断是每年的第几天 
 * 问题描述：通过键盘输入某年某月某日，判断这一天是这一年的第几天？        
 ```c
 #include<stdio.h>
int main()
{
	int year,month,day,leap,sum;
	printf("Please input year month day:\n ");      
	scanf("%d %d %d",&year,&month,&day);
    if(year%400==0||(year%4==0&&year%100!=0)) {      //闰年是公历中的名词，闰年分为普通闰年和世纪闰年。
	                                                 //1、普通闰年：公历年份是4的倍数的，且不是100的倍数，为普通闰年。（如2004、2020年就是闰年）；
													 //2、世纪闰年：公历年份是整百数的，必须是400的倍数才是世纪闰年（如1900年不是世纪闰年，2000年是世纪闰年）
    	leap=1;
    	
	}   
	else leap=0;
	switch(month)
	{
		case 1:sum=0;break;
		case 2:sum=31;break;
		case 3:sum=59;break;
		case 4:sum=90;break;
		case 5:sum=120;break;
		case 6:sum=151;break;
		case 7:sum=181;break;
		case 8:sum=212;break;
		case 9:sum=243;break;
		case 10:sum=273;break;
		case 11:sum=304;break;
		case 12:sum=334;break;
		default:{
			printf("month error:\n");   //这是最最标准的switchcase语句了，有case有break有default 
			break;
		}
								} 
		
		sum=sum+day;
		if(month>2){
			sum=sum+leap;
		}	
		printf("It is the %dth day.\n",sum);
		return 0;					
	                          
	
	
	
	
	
}                                    

 ```
 `还可以用一维数组来编写，这样程序会更简洁（将12个月份的天数放到一个长度为12的一维数组中）`
          
	  
  ## 0x5 循环结构的简单应用（水仙花数）
  * 问题描述：打印出所有的水仙花数。所谓水仙花数是指一个三位数，其各位数字立方和应等于该数本身。例如，153是一个水仙花数，因为153=1^3+5^3+3^3            
  * 习题目的：1. 为了掌握简单的for循环 2. 分解一个整数各个位的数字的方法
  * 思路：所有的水仙花数是100~999，取出数的每一位数字，求出它们的立方和，然后判断立方和是否与此数相等       
  ```c
  #include<stdio.h>
int main()
{
	int i,j,k,n;
	printf("water flower's numbers are:\n");
	for(i=100;i<=999;i++){
		j=i%10; //个位数字
		k=i/100;//百位数字
		n=i/10%10;//十位数字  还有一种取法是：i%100/10
		if(i==j*j*j+k*k*k+n*n*n){
			printf("%-5d",i);  //这个%-5d很有意思，我们可以程序运行时候把负号去掉，把5去掉看看都会发生些什么
			                  // 这个5表示这个数占5个位置，如果不足5位用0（空格）补全，-表示在右边补，没有负号表示在左边补 
		} 
		
		
	}
 return 0;
 
}
  
  
  
  ```
  
  ## 0x6 循环应用题（穷举算法）
  * 问题描述：某参观团按以下限制条件从A,B,C,D,E五个地方中选定若干参观点：      
  	1. 如果取A地，则必须去B地
  	2. D和E两地中只能去一地
  	3. C和B两地中只能去一地
  	4. C和D两地要么都去，要么都不去
  	5. 如果去E地，则必须去A和D地                       
  问该参观团能去哪几个地方？
  * 解题思路：用a,b,c,d,e五个整型变量，分别表示A,B,C,D,E是否去的状态。若变量值为1，则表示可去该地；若变量的值为0，则表示不去该地
  	1. 如果去A地，则必须去B地：表示A与B都去或A不去而B随便。表达式为(a&&b)||!a             
  	2. D和E两地中只能去一地，相应的表达式为d+e==1或(d&&!e)||(e&&!d)
  	3. B和C两地中只能去一地，相应的表达式为b+c==1或(b&&!c)||(c&&!b)
  	4. C和D要么都去，要么都不去，相应的表达式为c+d==2||c+d==0或(c&&d)||(!c&&!d)
  	5. 如果去E地，则必须去A和D地。这句话表示：E,A,D都去或E不去而A和D随便，相应的表达式为(e&&a&&d)||!e               
  根据题意，上面5个表达式是“与”的关系，由此可以得到总的表达式如下：        
  (a&&b)||!a && d+e==1 && b+c==1 && (c&&d)||(!c&&!d) && (e&&a&&d)||!e              
    
  * 穷举每个地方去（变量为1）或者不去（变量为0）的各种可能的情况，用上述逻辑表达式进行判断，使逻辑表达式为真（为1）的情况就是所求结果  //穷举是举尽，而枚举是对无数个例子所举出的数个有规律的例子。穷举不要求，但是枚举要求规律性 //个人认为穷举是举出全部的例子，而枚举只要求举出其中的一个或者多个就可以，不用全部列出。
  	
  ```c
  #include<stdio.h>
int main()
{
	int a,b,c,d,e;
	for(a=0;a<2;a++)
	for(b=0;b<2;b++)
	for(c=0;c<2;c++)
	for(d=0;d<2;d++)
	for(e=0;e<2;e++)
	{
		if((a&&b||!a)&&(d+e==1)&&(b+c==1)&&(c&&d||!c&&!d)&&(e&&a&&d||!e))
		{
			if(a)printf("去A地\n");    // if(变量)的意思是if（a!=0）的时候，即当a=1时输出去A地，当a=0时则不输出
			if(b)printf("去B地\n");
			if(c)printf("去C地\n");
			if(d)printf("去D地\n");
			if(e)printf("去E地\n");
			
		}
	}
}
  
  
  ```
  ## 0x7 循环应用题（试探算法）
  * 问题描述：某幼儿园按如下方法依次给A,B,C,D,E五个小孩发苹果。将全部苹果的一半再加二分之一个苹果发给第1个小孩；将剩下苹果的三分之一再加三分之一个苹果发给第2个小孩；将剩下的苹果的四分之一再加四分之一个苹果发给第3个小孩；将剩下苹果的五分之一再加五分之一个苹果发给第4个小孩；将剩下的11个苹果发给第5个小孩。每个小孩得到的苹果数均为整数。求原来共有多少个苹果？每个小孩各得到多少个苹果？    
  ```c
  #include<stdio.h>
int main()
{
	int n,flag,k,x,a,b,c,d,e;
	n=11;   //试探初始值，从11开始依次+1试探   n就是用来试探苹果总数是多少，x是用来存放符合条件的苹果总数 
	flag=1; //flag =1为试探标志，flag=0为找到解标志
	while(flag)  //意思就是while(flag!=0)，flag=0即循环结束找到解
	{
		x=n;  //先把n的值留下，程序中n会变，但后面还要用
		flag=0;
		for(k=1;k<=4&&flag==0;k++){  //模拟四次发苹果过程
		   if((n+1)%(k+1)==0)     //四次发苹果必须保证每次都是整数 
		       n=n-(n+1)/(k+1);
		   else 
		       flag=1;
		       
		 
			
		} 
		if(flag==0&&n!=11)
		    flag=1;  //如果每次都分配到整数个苹果，但最后剩下的苹果数不是11，还得继续试探 
		n=x+1; //留着n初始值的作用就在这里，因为11不符合条件，所以还得加1用12继续进行试探，直到试探出符合条件的数为止
		 
	 } 
	 printf("Total number of apple=%d\n",x);
	 
	 a=(x+1)/2;  //a=x/2+1/2=(x+1)/2
	 b=(x-a+1)/3;  //b=(x-a)/3+1/3=(x-a+1)/3
	 c=(x-a-b+1)/4; //......
	 d=(x-a-b-c+1)/5;
	 e=11;
	 printf("A=%d\n",a);
	 printf("B=%d\n",b);
	 printf("C=%d\n",c);
	 printf("D=%d\n",d);
	 printf("E=%d\n",e);
 } 
  ```
  
  ## 0x8 一般函数应用（孪子素数）
  ## 孪生素数就是指相差2的素数对，例如3和5，5和7，11和13…
  * 问题描述：编写一个程序，连续输出相邻的15对孪生素数。    
  要求：使用函数判断一个数是否为素数
  * 题目目的：1.掌握函数的使用（函数的定义，函数的返回值，函数的调用） 2. 判断一个数是否为素数的方法
  * 素数，是只能被1和它自身整除的数。要判断一个数s是否为素数，只要让s被2~（a-1）或者2~a/2之间的数一一试除，看看是否能被整除，即s%...==0。如果都不能整除s，则s是素数；但凡有一个能整除s，说明s不是素数           
  	* 数学方法：数学上已经证明，决定一个数s是否为素数，只须判断2~sqrt(s)之间的数有无能整除s的数就可以了
  ```c
  #include<stdio.h>
#include<math.h>   //用到了sqrt() 
//注意不管什么函数在前面，最先执行的都是main函数
int isprime(int s)   //isprime是一种函数，功能是判断素数。 
{                  /* 声明函数时必须声明函数的类型；带返回值的函数类型应该与其返回值类型相同，而没有
返回值的函数应声明为void类型     类型声明是函数定义的一部分，函数类型指的是返回值的类型，不是函数参数
的类型。例如，double link（int a,int b）定义了一个带两个int类型参数的函数，但是其返回值是double类型 */                  
	
	
	
	
	int flag=1,i=2;
	
	while(i<=(int)sqrt(s)&&flag)   //当i在2~sqrt(s)之间并且flag!=0时候，循环进行 
	{
		if(s%i==0)
		  flag=0;  //但凡发现了一个能整除s的数，说明s不是素数，立马令flag=0,终止循环 
		  
		else i++;  
		
	}
	return flag; }  /*1、return语句的作用

(1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行

(2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致

(3) return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。*/
int main() {	
int k,n;
	n=0;
	k=2;
	printf("找到了如下15对孪生素数：\n");
	while(n<15)
	{
		if(isprime(k)&&isprime(k+2)) //找到了一对孪生素数
		{
			n++;
			printf("%d,%d\n",k,k+2);
			
		 } 
		 k++;
		 
	 } 

}
 


  ```
  ## 0x8 递归调用的简单使用（连续数的倍数）
  * 问题描述：输入n和m，依次输出n的m倍，n-1的m倍，……，直到1的m倍。要求使用递归函数。如输入5，3，则输出为15 12 9 6 3
  ```c
  //这是个很简单的问题，直接用for循环结构就很容易解决
  #include<stdio.h>
int main()
{
	int n,m;
	int i;
	int t;
	scanf("%d %d",&n,&m);
	for(i=0;i<n;i++){
		t=(n-i)*m;
		printf("%3d",t);
		
	}
	return 0;
}

  ```
  * 为了掌握递归函数的使用，我们使用递归函数来实现
  * 递归的基本思想是：为求解规模为N的问题，设法将它分解成一些规模较小（如N-1）的问题，这些规模较小的子问题的性质和它们的父问题的性质是一样的，也就是它们可套用相同的算法来解决，并且这些规模较小的问题也可采用同样的方法，分解成规模更小的问题，……直到某个小问题可以直接求解，然后从这些小问题的解，逐步回归地构造出大问题的解       
  
  ## 0x9 函数嵌套调用的使用（最大公约数和最小公倍数）  
  * 问题描述：编写两个函数，分别求两个整数的最大公约数（指两个或多个整数共有约数中最大的一个）和最小公倍数，用主函数调用这两个函数，并输出结果
  * 分析：两个整数的最小公倍数等于它们的乘积除以它们的最大公约数。所以关键是先要搞出最大公约数
  * 方法：求最大公约数要用辗转相除方法；      
  假设求a和b的最大公约数，则       
  1. a除以b取余得c，若c=0，则b即为两数的最大公约数，输出，结束
  2. 若c！=0，则将b赋给a，c赋给b再返回上一步操作，继续执行       
  例如，求30和98的最大公约数，过程如下：
  ```c
  98 ÷ 30          余8（注意这里要用大数除以小数）
  30 ÷ 8           余6
  8 ÷ 6            余2
  6 ÷ 2            余0
  所以最大公约数为2.
  ```
          
```c
#include<stdio.h>
int gys(int m,int n)  //求最大公约数函数 
{
	int t;
	if(m<n){   //确保m比n的值大 
		t=m;    //如果m比n小的话，将m和n的值互换 
		m=n;
		n=t;
		
	}
	while(n!=0){    //当除数不为0时，辗转相除 
		t=m%n;
		m=n;
		n=t;
		
	}
	return m;  //return m是因为将最后得到的m值返回给主调函数main继续执行 
}

int gbs(int m,int n)  //gbs(int m,int n)是求m和n的最小公倍数的函数，因为m和n的最小公倍数=
                      //m*n÷它们的最大公倍数（可以调用gys（）来求），所以gbs调用了gys，且
					  //m和n作为实参从gbs（）传给gys（） 
					 
{
	int t;
	t=m*n/gys(m,n);
	return t;
}
 main()
{
	int a,b;
	printf("input a and b:");
	scanf("%d %d",&a,&b);
	printf("%d和%d最大公约数为%d\n",a,b,gys(a,b));
	printf("最小公倍数为%d\n",gbs(a,b));

}
```

## 0xA 数组的基本概念的应用
* 问题描述:已知A,B,C,D四个人中有一个人是小偷，并且这四个人中每人要么说真话，要么说假话。在审问过程中，这四个人分别回答如下：        
A说：B没有偷，是D偷的  //a[1]+a[3]==1                            
B说：我没有偷，是C偷的  //a[1]+a[2]==1                 
C说：A没有偷，是B偷的   //a[0]+a[1]==1                                     
D说：我没有偷   //a[0]+a[1]+a[2]+a[3]==1 以上这四个式子列的是因为它们说的不是真话就是假话，所以才这么列式子                 
* 方法思路：首先，定义具有四个元素的整型一维数组a，其数组元素a[0],a[1],a[2],a[3]，分别表示A,B,C,D四个人是否是小偷，且假定每个元素只能取值为0或1，值为1表示该人为小偷，值为0表示该人不是小偷         
根据四个人中的每一个人不管是不是小偷，它的回答要么是真话，要么是假话。因此，通过分析每一个人的回答，得到确定谁是小偷的条件为a[1]+a[3]==1 &&a[1]+a[2]==1 && a[0]+a[1]==1 && a[0]+a[1]+a[2]+a[3]==1
```c
#include<stdio.h>
int main()
{
	int i,j,a[4];
	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
			if(j==i)   //之所以这里还要搞个j的内部循环，就是为了假设第i个人为小偷，但其他三个人
			           //不是，我们要假设第i个人是小偷很容易，但要假设其他三人不是小偷时候，就必须再加一个j的内部循环 
			a[j]=1;
			else 
			a[j]=0;
		}
		if(a[1]+a[3]==1 && a[1]+a[2]==1 && a[0]+a[1]==1 && a[0]+a[1]+a[2]+a[3]==1) 
		printf("The thief is %c.\n",i+'A');//这里i+'A'很巧妙 
	}
	return 0;
}



```
`当处理大量相同类型的数据时，用数组是很方便的。远远比switch case和if else要方便的多`


## 0xB 一维数组的应用（排序问题）冒泡排序法
* 问题描述：通过键盘任意输入20个数，并将它们从小到大输出
* 排序法：排序的方法有很多，冒泡排序、选择排序、插入排序和快速排序等。本题使用冒泡排序法，冒泡排序的基本过程是：          
	1. 从第一个元素开始往后扫描数组，在扫描过程中依次比较相邻两个元素的大小，若前面元素大于后面的元素（与要求的升、降序不一致），则将它们交换。显然，第一次扫描结束后，最大的元素就移到了数组的最后
	2. 再用同样的方法从第一个元素开始扫描到数组的倒数第二个位置，这样数组的倒数第二个位置就放上了第二大的元素
	3. 再用同样的方法从第一个元素开始扫描到数组的倒数第三个位置，使得第三大的元素放在倒数第三位置上。……以此类推
		* 这样的方法就可以形象的想成被要求顺序的数一个一个冒出来排好                     
也就是说，要对20个数进行排序，需要扫描19次，利用for循环从0~18可以进行19次扫描。第0次扫描的过程是：从第0个到第18个元素，逐个和它的后一个元素比较，若大于它后面的元素，则交换；若小于它后面的元素，则保持原样。
```
#include<stdio.h>
void main()
{
	int a[20],i,j,t;
	printf("input 20 numbers:");
	for(i=0;i<20;i++){         
		scanf("%d",&a[i]);  //输入要排序的20个数，将这些数放到数组中 
		}
	for(i=0;i<19;i++){   //进行19次扫描 
		for(j=0;j<19-i;j++){
			if(a[j]>a[j+1]){
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			}
		}
		
	}
	printf("the finished numbers are:\n");
	for(i=0;i<20;i++){
      printf("%3d",a[i]);
	}
}
```

## 0xC 二维数组的应用（矩阵相乘）
* 问题描述：编程输出矩阵A与矩阵B的乘积矩阵C           
* 矩阵Am*n就是m*n个数排成m行n列的数表，可以用数组a[m][n]来表示。       
矩阵相乘的概念是：两个矩阵相乘A*B，A的列数必须等于B的行数。假设要计算C4*3=A4*5乘B5*3，那么就需要定义三个二维数组 A[4][5],B[5][3],C[4][3]。要计算矩阵C，就得计算数组C的各元素，所以需要使用for循环的二重嵌套来实现；而C的每一个元素又是通过累加求得，所以得再嵌套一个for循环，也就是说，此题需要三个for循环的嵌套
```
#include<stdio.h>
void main()
{
	int a[4][5],b[5][3],c[4][3];
	int i,j,line,sum;
	for(i=0;i<4;i++){  //输入矩阵A 
		printf("input matrix A's %d row:\n",i);   //外部循环定行，然后内部循环把这个行每一列的数字填好 
		for(j=0;j<5;j++)
		   scanf("%d",&a[i][j]);
	} 
	for(i=0;i<5;i++){      //输入矩阵B 
		printf("input matrix B's %d row:\n",i);
		for(j=0;j<3;j++)
		  scanf("%d",&a[i][j]);
		  
	}
	for(i=0;i<4;i++){   //计算矩阵C的第i行第j列元素 
		for(j=0;j<3;j++){
			sum=0;
			for(line=0;line<5;line++){
				sum=sum+a[i][line]*b[line][j];//A矩阵的第i行元素乘对应B矩阵第j列的各个元素后相加，得到一个值放在C矩阵的一个位置
				 c[i][j]=sum; 
				 
			}
			
			
	}
	}
	printf("the matrix c:\n");
	for(i=0;i<4;i++){
		for(j=0;j<3;j++){
			printf("%4d",c[i][j]);
		}
	}
	

	
}
```

## 0xD 字符串的使用（统计字符数）
* 问题描述：输入任意长度（不超过100个字符）的三个字符串，要求统计出其中共有多少个大写字母、小写字母、空格、数字和其它字符
* 字符串的应用非常广泛，但在C语言中没有字符串这个数据类型，只有字符数据类型。在C语言中，字符串有两种表示方法：**字符数组**和**字符指针**            
本题中使用**字符数组**表示字符串       
一个一维字符数组可表示一个字符串，一个二维字符数组可表示多个字符串。所以三个不超过100个字符的字符串就可以用二维数组char str[3][100]来表示。         
* 首先要输入三个字符串，也就是给字符数组str[3][100]的各行输入字符串初值，然后对字符数组str中的每个字符进行判断是哪一种字符，判断条件如下：         
是否为大写字母的条件：'A'<=str[][j]<='Z'      
是否为小写字母的条件：'a'<=str[][j]<='z'       
是否为数字的条件： '0'<=str[][j]<='9'      
是否为空格的条件：str[][j]==' '    
```
#include<stdio.h>
#include<string.h> //本题使用了统计字符串长度的函数strlen()，此函数在有关字符串操作的库函数头文件string.h中
int main()
{
	char str[3][100];
	int big=0,small=0,space=0,number=0,other=0,i,j; //分别表示大写字母，小写字母，空格，数字，其他字符
    for(i=0;i<3;i++){
    	printf("input the %dth string:",i+1); //（输入第几个字符串）
		gets(str[i]); //输入字符串的特定函数gets(),和scanf("%s",str[i]);同一作用 
	} 
	for(i=0;i<3;i++){
		for(j=0;j<strlen(str[i]);j++){
			if(str[i][j]>='A'&&str[i][j]<='Z')
			   big++;
			else if(str[i][j]>='a'&&str[i][j]<='z')
			   small++;
		    else if(str[i][j]>='0'&&str[i][j]<='9')
		       number++;
		    else if(str[i][j]==' ')
		       space++;
		    else 
		       other++;
		}
	}
	printf("big=%d,small=%d,number=%d,space=%d,other=%d\n",big,small,number,space,other);
	return 0;
	
	
	
 } 
```

## 0xE 指针数组的应用
* 问题描述：在主函数中输入10个长度不超过10的字符串，用另一个函数对它们排序，然后在主函数输出这10个已排好序的字符串。要求用指针数组来处理
* 分析：在0xD中说过字符串的两种表示方法：**字符数组**或**字符指针**。多个字符串的表示可以使用二维数组（即若干个一维数组）或指针数组（即字符指针的数组）。此题使用指针数组来对字符串进行排序。
* 回忆一下指针数组的概念：一个数组，其元素均为指针类型数据，称为指针数组，也就是说指针数组中的每一个元素都相当于一个指针变量。如定义一个字符指针数组char*str[10],就相当于定义了10个字符串，其中第j个字符串名就是str[j]。       
下面考虑排序方法，前面用过冒泡排序，这题我们用选择排序，根本思想：扫描整个待排序序列，从中选择最小元素，将它交换到序列的最前面，然后对剩下的子序列采用同样的方法，直到子序列为空             
                 
* 指针（pointer）是C语言最重要的概念之一，用于存储变量的地址。指针是一个值为内存地址的变量（汇编中的内存地址）
* 一元运算符&能给出变量的存储地址。例如：pooh = 24,假设pooh的存储地址是0B76，那么`printf("%d %p\n",pooh,&pooh);`将输出`24 0B76`
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











